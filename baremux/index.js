!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).BareMux={})}(this,function(e){"use strict";const t=globalThis.fetch,s=globalThis.SharedWorker,r=globalThis.localStorage,a=globalThis.navigator.serviceWorker,o=MessagePort.prototype.postMessage,n={prototype:{send:WebSocket.prototype.send},CLOSED:WebSocket.CLOSED,CLOSING:WebSocket.CLOSING,CONNECTING:WebSocket.CONNECTING,OPEN:WebSocket.OPEN};async function c(){const e=(await self.clients.matchAll({type:"window",includeUncontrolled:!0})).map(async e=>{const t=await function(e){let t=new MessageChannel;return new Promise(s=>{e.postMessage({type:"getPort",port:t.port2},[t.port2]),t.port1.onmessage=e=>{s(e.data)}})}(e);return await i(t),t}),t=Promise.race([Promise.any(e),new Promise((e,t)=>setTimeout(t,1e3,new TypeError("timeout")))]);try{return await t}catch(e){if(e instanceof AggregateError)throw new Error("All clients returned an invalid MessagePort.");return await c()}}function i(e){const t=new MessageChannel,s=new Promise((e,s)=>{t.port1.onmessage=t=>{"pong"===t.data.type&&e()},setTimeout(s,1500)});return o.call(e,{message:{type:"ping"},port:t.port2},[t.port2]),s}function l(e,t){const r=new s(e,"bare-mux-worker");return t&&a.addEventListener("message",t=>{if("getPort"===t.data.type&&t.data.port){const r=new s(e,"bare-mux-worker");o.call(t.data.port,r.port,[r.port])}}),r.port}let h=null;function d(){if(null===h){const e=new MessageChannel,t=new ReadableStream;let s;try{o.call(e.port1,t,[t]),s=!0}catch(e){s=!1}return h=s,s}return h}class p{constructor(e){this.channel=new BroadcastChannel("bare-mux"),e instanceof MessagePort||e instanceof Promise?this.port=e:this.createChannel(e,!0)}createChannel(e,t){if(self.clients)this.port=c(),this.channel.onmessage=e=>{"refreshPort"===e.data.type&&(this.port=c())};else if(e&&SharedWorker){if(!e.startsWith("/")&&!e.includes(":"))throw new Error("Invalid URL. Must be absolute or start at the root.");this.port=l(e,t),r["bare-mux-path"]=e}else{if(!SharedWorker)throw new Error("Unable to get a channel to the SharedWorker.");{const e=r["bare-mux-path"];if(!e)throw new Error("Unable to get bare-mux workerPath from localStorage.");this.port=l(e,t)}}}async sendMessage(e,t){this.port instanceof Promise&&(this.port=await this.port);try{await i(this.port)}catch{return this.createChannel(),await this.sendMessage(e,t)}const s=new MessageChannel,r=[s.port2,...t||[]],a=new Promise((e,t)=>{s.port1.onmessage=s=>{const r=s.data;"error"===r.type?t(r.error):e(r)}});return o.call(this.port,{message:e,port:s.port2},r),await a}}class w extends EventTarget{constructor(e,t=[],s,r){super(),this.protocols=t,this.readyState=n.CONNECTING,this.url=e.toString(),this.protocols=t;const a=e=>{this.protocols=e,this.readyState=n.OPEN;const t=new Event("open");this.dispatchEvent(t)},o=async e=>{const t=new MessageEvent("message",{data:e});this.dispatchEvent(t)},c=(e,t)=>{this.readyState=n.CLOSED;const s=new CloseEvent("close",{code:e,reason:t});this.dispatchEvent(s)},i=()=>{this.readyState=n.CLOSED;const e=new Event("error");this.dispatchEvent(e)};this.channel=new MessageChannel,this.channel.port1.onmessage=e=>{"open"===e.data.type?a(e.data.args[0]):"message"===e.data.type?o(e.data.args[0]):"close"===e.data.type?c(e.data.args[0],e.data.args[1]):"error"===e.data.type&&i()},s.sendMessage({type:"websocket",websocket:{url:e.toString(),protocols:t,requestHeaders:r,channel:this.channel.port2}},[this.channel.port2])}send(...e){if(this.readyState===n.CONNECTING)throw new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.");let t=e[0];t.buffer&&(t=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)),o.call(this.channel.port1,{type:"data",data:t},t instanceof ArrayBuffer?[t]:[])}close(e,t){o.call(this.channel.port1,{type:"close",closeCode:e,closeReason:t})}}function u(e,t,s){e.postMessage({type:"error",error:t})}function f(e){for(let t=0;t<e.length;t++){const s=e[t];if(!"!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~".includes(s))return!1}return!0}const y=["ws:","wss:"],g=[101,204,205,304],b=[301,302,303,307,308];class m{constructor(e){this.worker=new p(e)}createWebSocket(e,t=[],s,r){try{e=new URL(e)}catch(t){throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${e}' is invalid.`)}if(!y.includes(e.protocol))throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e.protocol}' is not allowed.`);Array.isArray(t)||(t=[t]),t=t.map(String);for(const e of t)if(!f(e))throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${e}' is invalid.`);r=r||{};return new w(e,t,this.worker,r)}async fetch(e,s){const r=new Request(e,s),a=s?.headers||r.headers,o=a instanceof Headers?Object.fromEntries(a):a,n=r.body;let c=new URL(r.url);if(c.protocol.startsWith("blob:")){const e=await t(c),s=new Response(e.body,e);return s.rawHeaders=Object.fromEntries(e.headers),s.rawResponse={body:e.body,headers:Object.fromEntries(e.headers),status:e.status,statusText:e.statusText},s.finalURL=c.toString(),s}for(let e=0;;e++){let t=(await this.worker.sendMessage({type:"fetch",fetch:{remote:c.toString(),method:r.method,headers:o,body:n||void 0}},n?[n]:[])).fetch,a=new Response(g.includes(t.status)?void 0:t.body,{headers:new Headers(t.headers),status:t.status,statusText:t.statusText});a.rawHeaders=t.headers,a.rawResponse=t,a.finalURL=c.toString();const i=s?.redirect||r.redirect;if(!b.includes(a.status))return a;switch(i){case"follow":{const t=a.headers.get("location");if(20>e&&null!==t){c=new URL(t,c);continue}throw new TypeError("Failed to fetch")}case"error":throw new TypeError("Failed to fetch");case"manual":return a}}}}e.BareClient=m,e.BareMuxConnection=class{constructor(e){this.worker=new p(e)}async getTransport(){return(await this.worker.sendMessage({type:"get"})).name}async setTransport(e,t,s){await this.setManualTransport(`\n\t\t\tconst { default: BareTransport } = await import("${e}");\n\t\t\treturn [BareTransport, "${e}"];\n\t\t`,t,s)}async setManualTransport(e,t,s){if("bare-mux-remote"===e)throw new Error("Use setRemoteTransport.");await this.worker.sendMessage({type:"set",client:{function:e,args:t}},s)}async setRemoteTransport(e,t){const s=new MessageChannel;s.port1.onmessage=async t=>{const s=t.data.port,r=t.data.message;if("fetch"===r.type)try{e.ready||await e.init(),await async function(e,t,s){const r=await s.request(new URL(e.fetch.remote),e.fetch.method,e.fetch.body,e.fetch.headers,null);if(!d()&&r.body instanceof ReadableStream){const e=new Response(r.body);r.body=await e.arrayBuffer()}r.body instanceof ReadableStream||r.body instanceof ArrayBuffer?o.call(t,{type:"fetch",fetch:r},[r.body]):o.call(t,{type:"fetch",fetch:r})}(r,s,e)}catch(e){u(s,e)}else if("websocket"===r.type)try{e.ready||await e.init(),await async function(e,t,s){const[r,a]=s.connect(new URL(e.websocket.url),e.websocket.protocols,e.websocket.requestHeaders,t=>{o.call(e.websocket.channel,{type:"open",args:[t]})},t=>{t instanceof ArrayBuffer?o.call(e.websocket.channel,{type:"message",args:[t]},[t]):o.call(e.websocket.channel,{type:"message",args:[t]})},(t,s)=>{o.call(e.websocket.channel,{type:"close",args:[t,s]})},t=>{o.call(e.websocket.channel,{type:"error",args:[t]})});e.websocket.channel.onmessage=e=>{"data"===e.data.type?r(e.data.data):"close"===e.data.type&&a(e.data.closeCode,e.data.closeReason)},o.call(t,{type:"websocket"})}(r,s,e)}catch(e){u(s,e)}},await this.worker.sendMessage({type:"set",client:{function:"bare-mux-remote",args:[s.port2,t]}},[s.port2])}getInnerPort(){return this.worker.port}},e.BareWebSocket=w,e.WebSocketFields=n,e.WorkerConnection=p,e.browserSupportsTransferringStreams=d,e.default=m,e.maxRedirects=20,e.validProtocol=f,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=index.js.map
